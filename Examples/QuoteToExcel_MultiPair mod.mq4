//+------------------------------------------------------------------+
//|                                  QuoteToExcel_MultiPair v1.1.mq4 |
//|                                     'gilani' at forexfactory.com |
//+------------------------------------------------------------------+
// Change Log
// 24-02-08 v1.1 - fixed the H1 chart running for requirement for H1 data generation. 
//          Now a chat can be running on any timeframe, H1 wil be generated by default

#property copyright "gilani // mod. fxdaytrader"
#property link "http://ForexBaron.net"
#define EANAME "QuoteToExcel_MultiPair v1.1"//"QuoteToExcel_MultiPair mod"
#include <stdlib.mqh>

extern int PeriodToExport = PERIOD_H1;
extern string upphi="******* Update period settings:";
extern int    timeframe        = PERIOD_H1;//PERIOD_D1;
extern string ucphi="false: use timeframe";
extern bool   UseCustomPeriod  = FALSE;
extern string tsmh="1:days, 2:hours, 3:minuts, 4:bars";
extern int    CustomPeriodMode = 1;//mode - 1:days, 2:hours, 3:minuts, 4:bars
extern double CustomPeriod     = 1.0;
//
extern bool ShowPopups     = TRUE;
extern bool PrintToJournal = TRUE;

string name; 
string pairs[]  = {"AUDJPY", "AUDUSD", "EURJPY", "EURUSD", "GBPJPY", "GBPUSD", "NZDJPY", "NZDUSD"};
string months[] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
int totalPairs;

int init() {
   name = EANAME;
   totalPairs = ArraySize (pairs);   
   return (0);
}

int start() {
  if ((!UseCustomPeriod && IsNewBar(timeframe))||(UseCustomPeriod && IsTimeForAction(timeframe,CustomPeriodMode,CustomPeriod))) doQuotes();
  return (0);
}

bool isConnected() {

 if (IsConnected() == false) {
  if (ShowPopups) Alert(EANAME+": You must be connected to the server first!");
  if (PrintToJournal) Print(EANAME+": You must be connected to the server first!");
  return(false);
 }
 return(true);
}

void doQuotes() {
   int err = 0;
   bool isError = false;
   string pairNames = "";
   
   if (!isConnected()) return;
   
   err = checkHistoryAvailability();
   if (err != 0) {
      if (ShowPopups) Alert(EANAME+": Error "+err+" - Unabe to update local history files!. Please rerun the script later");   
      if (PrintToJournal) Print(EANAME+": Error "+err+" - Unabe to update local history files!. Please rerun the script later");   
      return(0);
   }
   
   
   for (int x=0; x<totalPairs; x++) {
      pairNames = pairNames + pairs[x] + ",";   
      err = generateFile (pairs[x]);
      if (err != 0) {
         if (ShowPopups) Alert(EANAME+": Symbol(",pairs[x],") Error(",err,"): ",ErrorDescription(err));
         if (PrintToJournal) Print(EANAME+": Symbol(",pairs[x],") Error(",err,"): ",ErrorDescription(err));
         isError = true;
      }
   }
   
   if (isError == false) {
      if (ShowPopups) Alert(EANAME+": Successfully exported history data for "+totalPairs+" pairs - "+StringSubstr(pairNames,0, StringLen(pairNames)-1));
      if (PrintToJournal) Print(EANAME+": Successfully exported history data for "+totalPairs+" pairs - "+StringSubstr(pairNames,0, StringLen(pairNames)-1));
   } else {
      if (ShowPopups) Alert(EANAME+": Export unsuccessful! Please check the errors.");
      if (PrintToJournal) Print(EANAME+": Export unsuccessful! Please check the errors.");
   }

}
  
int generateFile (string symbol) {
   double O,H,L,C, T;   
   int availableBars = iBars(symbol, PeriodToExport);
      
   int totalBars = maxBarsToRead(PeriodToExport);
   if (availableBars < totalBars) totalBars = availableBars;

   int handle=FileOpen("100% RollOver_"+symbol+periodDesc(PeriodToExport)+".csv", FILE_CSV|FILE_WRITE, ',');
  
   FileWrite(handle, symbol+" "+periodDesc(PeriodToExport)+" (Export generated by "+name+")");
   FileWrite(handle, "DATE","HOUR","OPEN","HIGH","LOW","CLOSE");

   for (int i=0; i<totalBars; i++) {
      if(handle>0) {
         O = iOpen (symbol, PeriodToExport, i);
         H = iHigh (symbol, PeriodToExport, i);      
         L = iLow  (symbol, PeriodToExport, i);      
         C = iClose(symbol, PeriodToExport, i);               
         T = iTime (symbol, PeriodToExport, i);

         string date = TimeDay(T)+" "+months[TimeMonth(T)-1]+" "+TimeYear(T); //format - 21 Feburary 2008         
         string time = TimeToStr(T, TIME_MINUTES);
         
         FileWrite(handle, date, time, O, H, L, C);

      }
   } 
   
   FileClose(handle);
   return(GetLastError());
}
  
string periodDesc(int period) {
   if (period==0) period=Period();//fxdaytrader
   switch (period) {
      case PERIOD_M1:  return ("M1");
      case PERIOD_M5:  return ("M5");
      case PERIOD_M15: return ("M15");
      case PERIOD_M30: return ("M30");
      case PERIOD_H1:  return ("H1");
      case PERIOD_H4:  return ("H4");
      case PERIOD_D1:  return ("D1");
   }
   return ("");
}

int checkHistoryAvailability() {
   int bars;
   int err;
   int pause = 5;
   
   int maxBars = maxBarsToRead(PeriodToExport);
   
   for (int i=0;i <10; i++) {
      bars = maxBars;
      for (int x=0; x<totalPairs; x++) {
         int getBars = iBars(pairs[x], PeriodToExport);
         if (getBars < maxBars) bars = getBars;
      }
      err = GetLastError();
      if (err != 0 || bars < maxBars) {
         if (ShowPopups) Alert(EANAME+": Local history files are being updated from server. Attempting again in "+pause+" seconds... ");
         if (PrintToJournal) Print(EANAME+": Local history files are being updated from server. Attempting again in "+pause+" seconds... ");
         Sleep (pause*1000);
         pause += 2;
      } else {
         break;
      }
   }
   return (err);
}   



int maxBarsToRead (int period) {
   switch (period) {
      case PERIOD_M1:  return (1000);
      case PERIOD_M5:  return (1000);
      case PERIOD_M15: return (1000);
      case PERIOD_M30: return (1000);
      case PERIOD_H1:  return (720);
      case PERIOD_H4:  return (180);
      case PERIOD_D1:  return (60);
   }
      
  return (0);
}

bool IsTimeForAction(int timeframe,int CustomPeriodMode,double CustomPeriod) {
 double TimeForAction=0.0;
 static int lastActionTime=0;
 if (CustomPeriodMode==1) TimeForAction = CustomPeriod * 86400;//days
 if (CustomPeriodMode==2) TimeForAction = CustomPeriod * 3600;//hours
 if (CustomPeriodMode==3) TimeForAction = CustomPeriod * 60;//minutes
 if (CustomPeriodMode==4) TimeForAction = CustomPeriod * timeframe * 60;//bars     
   if ((TimeCurrent() - lastActionTime) >= TimeForAction) {
    lastActionTime=TimeCurrent();
    return(true);
    }//if (TimeCurrent() - ...
 return(false);
}

bool IsNewBar(int timeframe) {
 static int lasttime = 0;
 if (lasttime!=iTime(Symbol(),timeframe,0)) {
  lasttime=iTime(Symbol(),timeframe,0);
  return(true);
 }
 return(false);
}